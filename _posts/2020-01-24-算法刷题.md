---
layout: post
title: 算法刷题
date: 2020-01-24
#excerpt: "A ton of text to test readability."
tags: 
    - 算法刷题
comments: true
---

### 排序算法概览
"""
比较排序算法: 冒泡, 选择, 插入, 归并, 堆排, 快排
非比较排序算法: 计数, 基数, 桶排
稳定性: 7 个常用算法, 3 稳(冒泡, 插入, 归并) 4 不稳 (选择, 希尔, 快排, 堆排)
"""

#### 1 冒泡排序

"""
从后往前, 相邻的数据两两比较, 一趟完成后, 第一个元素为最大/小值
时间复杂度: O(n2)
最好情况: O(n), 当某次遍历没有发生交换, 则说明已经有序
最坏情况: O(n2), 数组刚好是逆序
空间复杂度: O(1)
稳定性: 是稳定的, 主要就是 遇到相等的元素时不要进行交换操作 即可
"""
Python 实现
"""
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        early_stop = 1 # 早停标志, 如果某次没有执行冒泡过程, 则说明已经有序
        for bubble in range(n-1, i, -1):
            if arr[bubble-1] > arr[bubble]: # 递增排序, 为了保证稳定性, 不能用 >=
            # if arr[i] < arr[j]: # 递减排序
                arr[bubble-1], arr[bubble] = arr[bubble], arr[bubble-1]
                early_stop = 0
        if early_stop:
            break
    return arr
print(bubble_sort(arr))
"""

#### 2 选择(交换)排序

"""
步骤:

在未排序序列中找到最小(大)元素, 存放到起始位置;
然后再从剩余的序列中继续寻找最小(大)元素, 并将其放到起始位置的下一个位置
以此类推, 直到所有元素排序完毕.
时间复杂度: O(n2)
最好情况: O(n2), 复杂度与序列元素分布形式无关
最坏情况: O(n2), 复杂度与序列元素分布形式无关
空间复杂度: O(1)
稳定性: 选择排序是不稳定的排序算法, 不稳定性发生在最小元素与 A[i] 交换的时刻. 因为选择排序在交换两个元素时, 是不考虑其他元素的相对位置的, 所以, 不管怎么样, 只要发生交换, 就一定会造成不稳定. 但是!!! 如果使用链表或者新开辟一个数组的话, 选择排序也是稳定的, 但实际上这种方法就没有交换的过程, 对于链表来说, 是把节点从链表中拿出来, 组成新的链表, 而不会对原来链表中的元素进行交换. 对于新开辟数组来说, 相当于是用空间换取稳定性, 同样也没有交换过程.
"""
Python 实现
"""
arr = [random.randint(0, 10) for _ in range(10)]
print(arr)
def select_sort(arr):
    n = len(arr)
    for i in range(n):
        select = i # 记录最值标记
        for j in range(i+1, n):
            if arr[j] < arr[select]: # 递增排序
                select = j # 更新最值标记
        arr[i], arr[select] = arr[select], arr[i] # 交换最值和当前的i值
    return arr
print(select_sort(arr))
"""

#### 3 插入排序

"""
将数据分为两个部分, 有序部分和无序部分, 一开始有序部分包含只包含第一个元素, 依次将无序部分的元素插入到有序部分 ( 插入的时间复杂度为 O(n) ), 直到所有元素插入完毕.

插入分为数组插入和链表插入(其实堆排序也算是一种插入排序)

下面的时间和空间复杂度均指 数组直接插入, 对于链表, 时间和空间都是 O(n)
时间复杂度: O(n2)
最好情况: O(n), 对于已经有序的序列来说, 每一次插入的复杂度都是 O(1), 共插入 O(n) 次.
最坏情况: O(n2), 对于逆序的序列来说, 每一次插入的复杂度都是 O(n), 共插入 O(n) 次.
空间复杂度: O(1)
稳定性: 只要在插入遇到相等元素时, 将新插入的放在最后, 那么就是稳定的.

插入排序不适合对于数据量比较大的排序应用. 但是, 如果需要排序的数据量很小, 比如量级小于千, 那么插入排序还是一个不错的选择. 插入排序在工业级函数库中也有着广泛的应用, 在 STL 的 sort 算法和 stdlib 的 qsort 算法中, 都将插入排序作为快速排序的补充, 用于少量元素的排序(通常为8个或以下).

步骤：

从第一个元素开始，该元素可以认为已经被排序
取出下一个元素，在已经排序的元素序列中从后向前扫描
如果被扫描的元素（已排序）大于新元素，将该元素后移一位
重复步骤3，直到找到已排序的元素刚好新元素的位置
将新元素插入到该位置后
重复步骤2~5
"""
Python 实现
"""
arr = [random.randint(0, 10) for _ in range(10)]
print(arr)
def insert_sort(arr):
    n = len(arr)
    for i in range(1, n):
        if arr[i] < arr[i-1]: # 只有当可能需要插入时, 才进行搜索, 否则就是已经有序, 这样最好复杂度可以为 O(n)
            for j in range(i):
                if arr[i] < arr[j]: # 递增排序, 为了保证稳定性, 不能使用 <=
                    temp = arr[i]
                    for k in range(i, j, -1):
                        arr[i] = arr[i-1]
                    arr[j] = temp
    return arr
print(insert_sort(arr))
"""
#### 4 希尔排序

"""
希尔排序(Shell Sort), 也叫 递减增量排序, 其实质是分组插入排序, 是插入排序中一种更高效的改进版本. 插入排序具有以下两点性质:

对于几乎已经排好序的数据操作时, 效率很高, 可以达到线性排序的效率;
插入排序在每次往前插入时只能将数据移动一位, 这使得效率较低.
因此, 希尔排序的思想是:
首先选取一个合适的步长(gap < n)作为间隔, 并将所有元素划分成 gap 个子序列, 每个子序列 内部元素之间的距离都是 gap.
分别对每个子序列使用直接插入排序.
缩小步长 gap 的值, 重复上面的分组和插入排序过程, 直到 gap = 1 为止.
时间复杂度: O(nlogn)
最好情况: O(n1.3), 实际中的时间复杂度与 gap 的值和序列元素的分布情况有关.
最坏情况: O(n2), 当 gap 的值为 1 时, 希尔排序就退化成了插入排序.
空间复杂度: O(1)
稳定性: 希尔排序是不稳定的算法, 因此对于相同的两个数, 可以由于分在不同的组中而导致它们的相对顺序发生变化. 比如序列：{ 3, 5, 10, 8, 7, 2, 8, 1, 20, 6 }, h=2时分成两个子序列 { 3, 10, 7, 8, 20 } 和 { 5, 8, 2, 1, 6 }, 未排序之前第二个子序列中的8在前面, 现在对两个子序列进行插入排序, 得到 { 3, 7, 8, 10, 20 } 和 { 1, 2, 5, 6, 8 }, 即 { 3, 1, 7, 2, 8, 5, 10, 6, 20, 8 }, 两个8的相对次序发生了改变.
"""
Python 实现
"""
arr = [random.randint(0, 15) for _ in range(20)]
print(arr)
def shell_sort(arr):
    n = len(arr)
    gap = round(n/2) # 初始时 gap 为 n / 2
    while gap > 0:
        for i in range(gap, n):
            temp = arr[i]
            j = i
            while(j >=gap and arr[j-gap] > temp): # 组内元素间隔为 gap, 进行插入排序
                arr[j] = arr[j-gap]
                j = j-gap
            arr[j] = temp
        gap = round(gap/2) # gap 缩小一半
    return arr
print(shell_sort(arr))
"""
